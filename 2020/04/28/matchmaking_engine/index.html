<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>撮合引擎学习 | H博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="交易撮合引擎（Matching/Trading Engine），顾名思义是用来撮合交易的软件，广泛地应用在 金融、证券、加密货币交易等领域。交易引擎负责管理加密资产市场中所有的开口订单（Open Orders）， 并在发现匹配的订单对（Trading Pair）时自动执行交易。本文将首先介绍有关加密资产交易撮合 引擎的基本概念，例如委托单、交易委托账本等，然后使用Golang实现一个原理性的撮合引">
<meta name="keywords" content="c++ java mysql shell linux h博客 android docker git laravel php python javascript python">
<meta property="og:type" content="article">
<meta property="og:title" content="撮合引擎学习">
<meta property="og:url" content="https://blog.newtao.vip/2020/04/28/matchmaking_engine/index.html">
<meta property="og:site_name" content="H博客">
<meta property="og:description" content="交易撮合引擎（Matching/Trading Engine），顾名思义是用来撮合交易的软件，广泛地应用在 金融、证券、加密货币交易等领域。交易引擎负责管理加密资产市场中所有的开口订单（Open Orders）， 并在发现匹配的订单对（Trading Pair）时自动执行交易。本文将首先介绍有关加密资产交易撮合 引擎的基本概念，例如委托单、交易委托账本等，然后使用Golang实现一个原理性的撮合引">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://blog.hubwiz.com/2019/07/22/build-a-crypto-exchange/arch.jpg">
<meta property="og:updated_time" content="2020-04-28T09:04:09.270Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="撮合引擎学习">
<meta name="twitter:description" content="交易撮合引擎（Matching/Trading Engine），顾名思义是用来撮合交易的软件，广泛地应用在 金融、证券、加密货币交易等领域。交易引擎负责管理加密资产市场中所有的开口订单（Open Orders）， 并在发现匹配的订单对（Trading Pair）时自动执行交易。本文将首先介绍有关加密资产交易撮合 引擎的基本概念，例如委托单、交易委托账本等，然后使用Golang实现一个原理性的撮合引">
<meta name="twitter:image" content="http://blog.hubwiz.com/2019/07/22/build-a-crypto-exchange/arch.jpg">
  
    <link rel="alternate" href="/atom.xml" title="H博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="/css/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<style>
.breathe-div {
    width: 200px;
    height: 200px;
    border: 1px solid #2b92d4;
    border-radius: 50%;
    text-align: center;
    cursor: pointer;
    margin:0px auto;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    overflow: hidden;
    z-index: 10;
    -webkit-animation-timing-function: ease-in-out;
    -webkit-animation-name: breathe;
    -webkit-animation-duration: 1500ms;
    -webkit-animation-iteration-count: infinite;
    -webkit-animation-direction: alternate;
}

@-webkit-keyframes breathe {
    0% {
        opacity: .4;
        box-shadow: 0 1px 2px rgba(0, 147, 223, 0.4), 0 1px 1px rgba(0, 147, 223, 0.1) inset;
    }

    100% {
        opacity: 1;
        border: 1px solid rgba(59, 235, 235, 0.7);
        box-shadow: 0 1px 30px #0093df, 0 1px 20px #0093df inset;
    }
}
.breathe-point{position:absolute;left:50%; top:150px;}
.breathe-div{position:absolute;left:-100px; top:-100px }
</style>
<body>
  <div class="breathe-point">
  <div class="breathe-div"></div>
  </div>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">H博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://blog.newtao.vip"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="true-matchmaking_engine" class="article article-type-true" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/28/matchmaking_engine/" class="article-date">
  <time datetime="2020-04-28T09:04:09.270Z" itemprop="datePublished">2020-04-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/交易所/">交易所</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      撮合引擎学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>交易撮合引擎（Matching/Trading Engine），顾名思义是用来撮合交易的软件，广泛地应用在 金融、证券、加密货币交易等领域。交易引擎负责管理加密资产市场中所有的开口订单（Open Orders）， 并在发现匹配的订单对（Trading Pair）时自动执行交易。本文将首先介绍有关加密资产交易撮合 引擎的基本概念，例如委托单、交易委托账本等，然后使用Golang实现一个原理性的撮合引擎。如果你正在 考虑实现类似交易所（Exchange）这样的产品，相信本文会对你有很大的帮助。</p>
<p>可以这样先思考一下：如果你要实现一个供人们将以太币兑换为比特币的市场，那么你就需要跟踪一些信息， 例如以太币的买/卖价格（以比特币计算）、哪些买单或卖单还没有执行等等，同时还要处理新进来的委托单。 将这一思路扩展到多个交易对，然后再集成钱包功能，你就实现了一个完整的交易引擎，就像 币安一样。</p>
<p>本文的完整源码下载地址：<a href="https://github.com/ezpod/crypto-exchange-engine" target="_blank" rel="noopener">crypto-exchange-engine</a></p>
<h1 id="1、基本概念与术语"><a href="#1、基本概念与术语" class="headerlink" title="1、基本概念与术语"></a>1、基本概念与术语</h1><p>在开始打造交易撮合引擎之前，让我们首先熟悉相关的基本概念与术语。</p>
<h2 id="撮合-交易引擎"><a href="#撮合-交易引擎" class="headerlink" title="撮合/交易引擎"></a>撮合/交易引擎</h2><p>正如前面所述，交易撮合引擎是用来撮合交易的软件，可以先把交易撮合引擎看作 一个黑盒子，它有一些输入和输出。<br>例如，可能的输入包括：</p>
<ul>
<li>创建新的委托单（NewOrder）：一个新的委托单可以作为交易撮合引擎的输入，引擎会尝试将其与已有的 委托单进行撮合。</li>
<li>取消已有的委托单（CancelOrder）：用户也可以取消一个之前输入的委托单，如果它还没有执行的话，即开口订单。</li>
</ul>
<p>当然你可以定义其他的输入，出于简化考虑，我们现在只定义上述两个输入。</p>
<p>交易撮合引擎的输出是一些事件，以便及时通知其他应用处理。例如，当 引擎撮合了一笔交易后，就会触发一个TradesGenerated事件；而当取消了 一个已有的委托单后，引擎就会触发OrderCancelled。同样，你可以根据自己 的需求来定义引擎的输出，这里我们还是简单点，只定义这两个输出事件。</p>
<h2 id="交易委托账本"><a href="#交易委托账本" class="headerlink" title="交易委托账本"></a>交易委托账本</h2><p>交易委托账本（Order Book）就是一个买方委托单或买方委托单的列表，通常按照 价格和时间排序。</p>
<p>当一个新的买方（买方）委托单进入引擎后，引擎就会将尝试其与现有的卖方（买方）委托账本 进行匹配，看是否存在执行交易的可能。如果找到了匹配的对手单，引擎就可以执行这两个 委托单了，也就是撮合成功了。</p>
<h2 id="委托单"><a href="#委托单" class="headerlink" title="委托单"></a>委托单</h2><p>在任何交易引擎中，都可能有多种类型的委托单供用户选择。其中常见的类型包括：</p>
<ul>
<li>限价委托单<br>限价委托单是在当前的加密货币交易环境中最常用的委托类型。这种委托单允许用户 指定一个价格，只有当撮合引擎找到同样价格甚至更好价格的对手单时才执行交易。<br>对于一个买方委托单而言，这意味着如果你的委托价格是￥100，那么该委托单将会 在任何不高于￥100的价格成交 —— 买到指定的价格或者更便宜的价格；而对于一个 卖方委托单而言，同样的委托价格意味着该委托单将在任何不低于￥100的价格成交 —— 卖出指定的价格或者更高的价格。</li>
<li>市价委托单<br>市价委托单的撮合会完全忽略价格因素，而致力于有限完成指定数量的成交。市价 委托单在交易委托账本中有较高的优先级，在流动性充足的市场中市价单可以保证成交。</li>
</ul>
<p>例如，当用户委托购买2个以太币时，该委托单可以在￥900、￥1000、￥2000或任何 其他价位成交，这依赖于市场中当前的敞口委托单的情况。</p>
<ul>
<li>止损委托单<br>止损委托单尽在市场价格到达指定价位时才被激活，因此它的执行方式与市价委托单 相反。一旦止损委托单激活，它们可以自动转化为市价委托单或限价委托单。</li>
</ul>
<p>如果你希望打造一个高级的交易所，那么还有其他一些需要了解的概念，例如流动性、 多/空交易、FIX/FAST协议等等，但是同样出于简化考虑，我们将这些内容留给你自己 去发现。</p>
<h1 id="2、系统架构"><a href="#2、系统架构" class="headerlink" title="2、系统架构"></a>2、系统架构</h1><p>现在，对于交易撮合引擎的构成我们已经有了一些了解，那么让我们看一下整个系统 的架构，以及我们将要使用的技术：</p>
<p><img src="http://blog.hubwiz.com/2019/07/22/build-a-crypto-exchange/arch.jpg" alt="系统架构"></p>
<p>正如你上面看到的，我们的系统将包含引擎的多个客户端，这些客户端可以是交易所 系统中的其他组件，例如接收终端用户委托请求的App等等。</p>
<p>在客户端和引擎之间的通信是使用Apache Kafka作为消息总线来实现的，每个交易对 都对应Kafka的一个主题，这样我们可以确保当消息队列接收到用户委托单时，引擎 将以同样的先后顺序处理委托单。这保证了即使引擎崩溃重启我们也可以重建交易 委托账本。</p>
<p>引擎将监听Kafka主题，执行委托账本命令并将引擎的输出事件发布到消息队列中。 当然如果能够监测委托单的处理速度以及交易的执行情况会更酷。我们可以使用 Prometheus来采集性能指标，使用grafana来实现一个监视仪表盘。</p>
<h1 id="3、开发语言选择"><a href="#3、开发语言选择" class="headerlink" title="3、开发语言选择"></a>3、开发语言选择</h1><p>可以选择你熟悉的开发语言，不过由于交易撮合引擎计算量巨大，通常我们应当选择 底层系列的语言，例如：C/C++、GoLang、Rust、Java等等。在这个教程中，我们使用 Golang，因为它很快、容易理解、并发实现简单，而且我也有好久没有用C++了。</p>
<h1 id="4、开发交易撮合引擎"><a href="#4、开发交易撮合引擎" class="headerlink" title="4、开发交易撮合引擎"></a>4、开发交易撮合引擎</h1><p>我们将按照以下的步骤来开发交易撮合引擎：</p>
<ul>
<li>基础类型定义</li>
<li>Consumer实现</li>
<li>Order Book实现</li>
<li>Producer实现</li>
<li>Monitoring实现<h2 id="4-1-基础类型定义"><a href="#4-1-基础类型定义" class="headerlink" title="4.1 基础类型定义"></a>4.1 基础类型定义</h2>我们需要首先定义一些基础类型，这包括Order、OrderBook和Trade，分别表示委托单、 交易委托账本和交易：</li>
</ul>
<p>下面是engine/order.go文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package engine</span><br><span class="line"></span><br><span class="line">import &quot;encoding/json&quot;</span><br><span class="line"></span><br><span class="line">type Order struct &#123;</span><br><span class="line">	Amount uint64 `json:&quot;amount&quot;`</span><br><span class="line">	Price  uint64 `json:&quot;price&quot;`</span><br><span class="line">	ID     string `json:&quot;id&quot;`</span><br><span class="line">	Side   int8   `json:&quot;side&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (order *Order) FromJSON(msg []byte) error &#123;</span><br><span class="line">	return json.Unmarshal(msg, order)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (order *Order) ToJSON() []byte &#123;</span><br><span class="line">	str, _ := json.Marshal(order)</span><br><span class="line">	return str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们就是简单地创建了一个结构用来记录订单的主要信息，然后添加了一个 方法用于快速的JSON转换。</p>
<p>类似地engine/trade.go文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package engine</span><br><span class="line"></span><br><span class="line">import &quot;encoding/json&quot;</span><br><span class="line"></span><br><span class="line">type Trade struct &#123;</span><br><span class="line">	TakerOrderID string `json:&quot;taker_order_id&quot;`</span><br><span class="line">	MakerOrderID string `json:&quot;maker_order_id&quot;`</span><br><span class="line">	Amount       uint64 `json:&quot;amount&quot;`</span><br><span class="line">	Price        uint64 `json:&quot;price&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (trade *Trade) FromJSON(msg []byte) error &#123;</span><br><span class="line">	return json.Unmarshal(msg, trade)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (trade *Trade) ToJSON() []byte &#123;</span><br><span class="line">	str, _ := json.Marshal(trade)</span><br><span class="line">	return str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在我们已经定义了基本的输入和输出类型，现在看看交易委托账本 engine/order_book.go文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package engine</span><br><span class="line"></span><br><span class="line">// OrderBook type</span><br><span class="line">type OrderBook struct &#123;</span><br><span class="line">	BuyOrders  []Order</span><br><span class="line">	SellOrders []Order</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Add a buy order to the order book</span><br><span class="line">func (book *OrderBook) addBuyOrder(order Order) &#123;</span><br><span class="line">	n := len(book.BuyOrders)</span><br><span class="line">	var i int</span><br><span class="line">	for i := n - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">		buyOrder := book.BuyOrders[i]</span><br><span class="line">		if buyOrder.Price &lt; order.Price &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if i == n-1 &#123;</span><br><span class="line">		book.BuyOrders = append(book.BuyOrders, order)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		copy(book.BuyOrders[i+1:], book.BuyOrders[i:])</span><br><span class="line">		book.BuyOrders[i] = order</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Add a sell order to the order book</span><br><span class="line">func (book *OrderBook) addSellOrder(order Order) &#123;</span><br><span class="line">	n := len(book.SellOrders)</span><br><span class="line">	var i int</span><br><span class="line">	for i := n - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">		sellOrder := book.SellOrders[i]</span><br><span class="line">		if sellOrder.Price &gt; order.Price &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if i == n-1 &#123;</span><br><span class="line">		book.SellOrders = append(book.SellOrders, order)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		copy(book.SellOrders[i+1:], book.SellOrders[i:])</span><br><span class="line">		book.SellOrders[i] = order</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Remove a buy order from the order book at a given index</span><br><span class="line">func (book *OrderBook) removeBuyOrder(index int) &#123;</span><br><span class="line">	book.BuyOrders = append(book.BuyOrders[:index], book.BuyOrders[index+1:]...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Remove a sell order from the order book at a given index</span><br><span class="line">func (book *OrderBook) removeSellOrder(index int) &#123;</span><br><span class="line">	book.SellOrders = append(book.SellOrders[:index], book.SellOrders[index+1:]...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在交易委托账本中，除了创建保存买/卖方委托单的列表外，我们还需要定义添加新委托单 的方法。</p>
<p>委托单列表应当根据其类型按升序或降序排列：卖方委托单是按降序排列的，这样在列表中 序号最大的委托单价格最低；买方委托单是按升序排列的，因此在其列表中最后的委托单价格 最高。</p>
<p>由于绝大多数交易会在市场价格附近成交，我们可以轻松地从这些数组中插入或移除成员。</p>
<p>现在让我们来处理委托单。</p>
<p>在下面的代码中我们添加了一个命令来实现对限价委托单的处理。</p>
<p>文件engine/order_book_limit_order.go的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">package engine</span><br><span class="line"></span><br><span class="line">// Process an order and return the trades generated before adding the remaining amount to the market</span><br><span class="line">func (book *OrderBook) Process(order Order) []Trade &#123;</span><br><span class="line">	if order.Side == 1 &#123;</span><br><span class="line">		return book.processLimitBuy(order)</span><br><span class="line">	&#125;</span><br><span class="line">	return book.processLimitSell(order)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Process a limit buy order</span><br><span class="line">func (book *OrderBook) processLimitBuy(order Order) []Trade &#123;</span><br><span class="line">	trades := make([]Trade, 0, 1)</span><br><span class="line">	n := len(book.SellOrders)</span><br><span class="line">	// check if we have at least one matching order</span><br><span class="line">	if n != 0 || book.SellOrders[n-1].Price &lt;= order.Price &#123;</span><br><span class="line">		// traverse all orders that match</span><br><span class="line">		for i := n - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">			sellOrder := book.SellOrders[i]</span><br><span class="line">			if sellOrder.Price &gt; order.Price &#123;</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">			// fill the entire order</span><br><span class="line">			if sellOrder.Amount &gt;= order.Amount &#123;</span><br><span class="line">				trades = append(trades, Trade&#123;order.ID, sellOrder.ID, order.Amount, sellOrder.Price&#125;)</span><br><span class="line">				sellOrder.Amount -= order.Amount</span><br><span class="line">				if sellOrder.Amount == 0 &#123;</span><br><span class="line">					book.removeSellOrder(i)</span><br><span class="line">				&#125;</span><br><span class="line">				return trades</span><br><span class="line">			&#125;</span><br><span class="line">			// fill a partial order and continue</span><br><span class="line">			if sellOrder.Amount &lt; order.Amount &#123;</span><br><span class="line">				trades = append(trades, Trade&#123;order.ID, sellOrder.ID, sellOrder.Amount, sellOrder.Price&#125;)</span><br><span class="line">				order.Amount -= sellOrder.Amount</span><br><span class="line">				book.removeSellOrder(i)</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// finally add the remaining order to the list</span><br><span class="line">	book.addBuyOrder(order)</span><br><span class="line">	return trades</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Process a limit sell order</span><br><span class="line">func (book *OrderBook) processLimitSell(order Order) []Trade &#123;</span><br><span class="line">	trades := make([]Trade, 0, 1)</span><br><span class="line">	n := len(book.BuyOrders)</span><br><span class="line">	// check if we have at least one matching order</span><br><span class="line">	if n != 0 || book.BuyOrders[n-1].Price &gt;= order.Price &#123;</span><br><span class="line">		// traverse all orders that match</span><br><span class="line">		for i := n - 1; i &gt;= 0; i-- &#123;</span><br><span class="line">			buyOrder := book.BuyOrders[i]</span><br><span class="line">			if buyOrder.Price &lt; order.Price &#123;</span><br><span class="line">				break</span><br><span class="line">			&#125;</span><br><span class="line">			// fill the entire order</span><br><span class="line">			if buyOrder.Amount &gt;= order.Amount &#123;</span><br><span class="line">				trades = append(trades, Trade&#123;order.ID, buyOrder.ID, order.Amount, buyOrder.Price&#125;)</span><br><span class="line">				buyOrder.Amount -= order.Amount</span><br><span class="line">				if buyOrder.Amount == 0 &#123;</span><br><span class="line">					book.removeBuyOrder(i)</span><br><span class="line">				&#125;</span><br><span class="line">				return trades</span><br><span class="line">			&#125;</span><br><span class="line">			// fill a partial order and continue</span><br><span class="line">			if buyOrder.Amount &lt; order.Amount &#123;</span><br><span class="line">				trades = append(trades, Trade&#123;order.ID, buyOrder.ID, buyOrder.Amount, buyOrder.Price&#125;)</span><br><span class="line">				order.Amount -= buyOrder.Amount</span><br><span class="line">				book.removeBuyOrder(i)</span><br><span class="line">				continue</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// finally add the remaining order to the list</span><br><span class="line">	book.addSellOrder(order)</span><br><span class="line">	return trades</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来我们将一个方法变成了两个，分别处理买方委托单和卖方委托单。这两个方法在每个方面 都很相似，除了处理的市场侧不同。</p>
<p>算法非常简单。我们将一个买方委托单与所有的卖方委托单进行匹配，找出任何与买方委托价格 一致甚至更低的卖方委托单。当这一条件不能满足时，或者该买方委托单完成后，我们返会撮合 的交易。</p>
<p>现在就快完成我们的交易引擎了，还需要接入Apache Kafka服务器，然后开始监听委托单。</p>
<p>main.go文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;engine/engine&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line"></span><br><span class="line">	&quot;github.com/Shopify/sarama&quot;</span><br><span class="line">	cluster &quot;github.com/bsm/sarama-cluster&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">	// create the consumer and listen for new order messages</span><br><span class="line">	consumer := createConsumer()</span><br><span class="line"></span><br><span class="line">	// create the producer of trade messages</span><br><span class="line">	producer := createProducer()</span><br><span class="line"></span><br><span class="line">	// create the order book</span><br><span class="line">	book := engine.OrderBook&#123;</span><br><span class="line">		BuyOrders:  make([]engine.Order, 0, 100),</span><br><span class="line">		SellOrders: make([]engine.Order, 0, 100),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// create a signal channel to know when we are done</span><br><span class="line">	done := make(chan bool)</span><br><span class="line"></span><br><span class="line">	// start processing orders</span><br><span class="line">	go func() &#123;</span><br><span class="line">		for msg := range consumer.Messages() &#123;</span><br><span class="line">			var order engine.Order</span><br><span class="line">			// decode the message</span><br><span class="line">			order.FromJSON(msg.Value)</span><br><span class="line">			// process the order</span><br><span class="line">			trades := book.Process(order)</span><br><span class="line">			// send trades to message queue</span><br><span class="line">			for _, trade := range trades &#123;</span><br><span class="line">				rawTrade := trade.ToJSON()</span><br><span class="line">				producer.Input() &lt;- &amp;sarama.ProducerMessage&#123;</span><br><span class="line">					Topic: &quot;trades&quot;,</span><br><span class="line">					Value: sarama.ByteEncoder(rawTrade),</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			// mark the message as processed</span><br><span class="line">			consumer.MarkOffset(msg, &quot;&quot;)</span><br><span class="line">		&#125;</span><br><span class="line">		done &lt;- true</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	// wait until we are done</span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Create the consumer</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">func createConsumer() *cluster.Consumer &#123;</span><br><span class="line">	// define our configuration to the cluster</span><br><span class="line">	config := cluster.NewConfig()</span><br><span class="line">	config.Consumer.Return.Errors = false</span><br><span class="line">	config.Group.Return.Notifications = false</span><br><span class="line">	config.Consumer.Offsets.Initial = sarama.OffsetOldest</span><br><span class="line"></span><br><span class="line">	// create the consumer</span><br><span class="line">	consumer, err := cluster.NewConsumer([]string&#123;&quot;127.0.0.1:9092&quot;&#125;, &quot;myconsumer&quot;, []string&#123;&quot;orders&quot;&#125;, config)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;Unable to connect consumer to kafka cluster&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	go handleErrors(consumer)</span><br><span class="line">	go handleNotifications(consumer)</span><br><span class="line">	return consumer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handleErrors(consumer *cluster.Consumer) &#123;</span><br><span class="line">	for err := range consumer.Errors() &#123;</span><br><span class="line">		log.Printf(&quot;Error: %s\n&quot;, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handleNotifications(consumer *cluster.Consumer) &#123;</span><br><span class="line">	for ntf := range consumer.Notifications() &#123;</span><br><span class="line">		log.Printf(&quot;Rebalanced: %+v\n&quot;, ntf)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// Create the producer</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">func createProducer() sarama.AsyncProducer &#123;</span><br><span class="line">	config := sarama.NewConfig()</span><br><span class="line">	config.Producer.Return.Successes = false</span><br><span class="line">	config.Producer.Return.Errors = true</span><br><span class="line">	config.Producer.RequiredAcks = sarama.WaitForAll</span><br><span class="line">	producer, err := sarama.NewAsyncProducer([]string&#123;&quot;127.0.0.1:9092&quot;&#125;, config)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(&quot;Unable to connect producer to kafka server&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	return producer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用Golang的Sarama Kafka客户端开发库，我们可以分别创建一个接入Kafka的消费者和生产者。</p>
<p>消费者将在指定的Kafka主题上等待新的委托单，然后进行撮合处理。生成的交易接下来使用 生产者发送到指定的交易主题。</p>
<p>Kafka消息采用字节数组编码，因此我们需要将其解码。反之，将交易传入消息队列时，我们 还需要进行必要的编码。</p>
<h1 id="5、结语"><a href="#5、结语" class="headerlink" title="5、结语"></a>5、结语</h1><p>现在你有了一个可伸缩的交易引擎！完整的代码可以在GITHUB下载：crypto-exchange-engine。</p>
<p>不过这个引擎的目的是教学，另外代码还支持很多进一步的优化，例如：</p>
<ul>
<li>使用一种更高效的匹配算法</li>
<li>添加取消订单的功能</li>
<li>增强通信能力</li>
<li>委托账本的备份与恢复</li>
<li>添加监视功能</li>
</ul>
<p>英文原文链接：<a href="https://around25.com/blog/building-a-trading-engine-for-a-crypto-exchange/" target="_blank" rel="noopener">How to Build a Trading Engine </a></p>
<p>翻译原文链接: <a href="http://blog.hubwiz.com/2019/07/22/build-a-crypto-exchange/" target="_blank" rel="noopener">交易撮合引擎原理与实现【含源码】</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://blog.newtao.vip/2020/04/28/matchmaking_engine/" data-id="ckhlpbtke0023iu783v2jw8jn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/28/blockchain_btc/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          区块链-比特币
        
      </div>
    </a>
  
  
    <a href="/2020/04/13/openldap_memberof/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">如何在OpenLDAP启用MemberOf</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/CTF/">CTF</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/GIT/">GIT</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mac/">Mac</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Mysql/">Mysql</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/中间件/">中间件</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/交易所/">交易所</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/区块链/">区块链</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/后端/">后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务/">微服务</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/汇编/">汇编</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/源码/">源码</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络安全/">网络安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/运维/">运维</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/阿里云/">阿里云</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/29/sshd_ip/">防火墙ssh白名单</a>
          </li>
        
          <li>
            <a href="/2020/07/15/aliyun_disk/">磁盘扩容</a>
          </li>
        
          <li>
            <a href="/2020/07/10/wget_c/">wget</a>
          </li>
        
          <li>
            <a href="/2020/07/08/ctf/">安全领域资源</a>
          </li>
        
          <li>
            <a href="/2020/07/08/asm/">汇编指令集</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 anonymous<br>
      Powered by <a href="https://baike.baidu.com/item/%E5%8C%BF%E5%90%8D%E8%80%85%E9%BB%91%E5%AE%A2%E7%BB%84%E7%BB%87/8378313?fromtitle=Anonymous&fromid=7157039&fr=aladdin" target="_blank">H</a>
      <a href="http://beian.miit.gov.cn">鲁ICP备18014570号</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="/js/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  </div>
    <!-- waifu-tips.js 依赖 JQuery 库 -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <!-- 实现拖动效果，需引入 JQuery UI -->
    <script src="https://cdn.jsdelivr.net/npm/jquery-ui-dist@1.12.1/jquery-ui.min.js"></script>
    <script src="images/assets/autoload.js?v=1.4.2"></script>
</body>
</html>
